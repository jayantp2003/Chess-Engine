Sequence of Project 
Video 1:
1. We created a directory for all our files
2. We created ChessMain.py for all Driver, input output codes
3. We created ChessEngine.py which checks and updates the state of the pieces
4. Then we defined a class named Gamestate in ChessEngine where we defined the initial state of the board and then defined the initial turn and movelog list as empty in the constructor of the gamestate class
5. Then in our main file, we imported the ChessEngine and also imported the python module pygame, which gives us the functionality to design a display of certain width and height, we can use that screen object to fill colors(colors are available in the pygame color attribute), we can draw rectangles on the screen which will be used to design the board, the screen object also has a feature of blit which can be used to stick stamp like images onto the screen. And this is how using nested for loops on the state of the board accessed from ChessEngine.Gamestate.board, we can get the position of every piece and using the list which maps every image to string, we can position the pieces of chess on the board and we are done with the look part...

Video 2:
Now we look into working of the moves.
6. pygame provides us a screen and a certain number of functionality on the screen, like we can hear the events like if user clicks on the quit button or user clicked on the board, we used the second one for the motion of the pieces where we used two variables, one to store the current clicked box and another to store the second clicked box, we put the condition that if one box is clicked twice, we reset the two variables, otherwise we noted both the coordinates and then we implemented a class in the ChessEngine name Move, where we stored the variables denoting which box was moved to what and which element was captured, we created another function to get the notations, also we created a mapping so that we can store the logs in the way a original chess game looks like.
7. Then we implemented the makeMove method in Gamestate class where we changed the originalstate of the original position to -- and set the newstate to the current captured state or the place where the piece was moved. and appended the log and changed the turn for the another person to move.

Video 3:
We are now ready with our display, now we need to setup conditions in order to restrict users from making any invalid move.
8. Firstly we added the undo feature to our game, pygame provides us with eventlistener to capture keyboard strokes and when ever a user presses z we can use it to undo the move. For undo feature, we created a method in our gamestate class for undoMove in which we used the log of moves and if it is not empty, we took the first move and then reseted the values at that the present and previous positions. Now we are done with our undo move and we need to check whether the user has clicked for valid move or not for this we need to generate all possible valid moves for a selected piece on the board and then check whether the move is present in that list or not.
9. Now we generate valid moves for each piece on the board and also note the capturing motion of a key 